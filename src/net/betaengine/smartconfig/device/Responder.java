/**
 * Copyright 2013 George C. Hawkins
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.betaengine.smartconfig.device;

import java.net.DatagramPacket;
import java.net.DatagramSocket;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.NetworkInterface;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.util.Collections;

import com.google.common.base.Charsets;

public class Responder
{
    private final static String DEFAULT_DEVICE_NAME = "CC3000"; // Chosen by TI.
    
    private static final byte[] MDNS_MULTICAST_GROUP = toBytes(224, 0, 0, 251);
    private static final int MDNS_PORT = 5353;
    
    private final static int TYPE_A = 1;
    private final static int TYPE_PTR = 12;
    private final static int TYPE_TXT = 16;
    private final static int TYPE_SRV = 33;
    
    private final static int CLASS_INTERNET = 1;
    
    public static void main(String[] args)
    {
        if (args.length > 1)
        {
            System.err.println("Usage: java " + Responder.class.getName() + " [device-name]");
            System.exit(1);
        }
        
        String deviceName = args.length == 1 ? args[0] : DEFAULT_DEVICE_NAME;
        Responder responder = new Responder();
        
        responder.send(deviceName);
    }
    
    private void send(String deviceName)
    {
        try
        {
            DatagramSocket socket = new DatagramSocket();

            byte[] data = createMessageData(deviceName);
            
            InetAddress group = InetAddress.getByAddress(MDNS_MULTICAST_GROUP);
            DatagramPacket packet = new DatagramPacket(data, data.length, group, MDNS_PORT);
            
            socket.send(packet);
            socket.close();
        }
        catch (Exception e)
        {
            e.printStackTrace();
            System.exit(1);
        }
    }
    
    // Mimics mDNS message generated by CC3000 with firmware version 1.19.
    private byte[] createMessageData(String deviceName)
    {
        WireFormat out = new WireFormat();
        
        // See:
        // * mDNS - http://en.wikipedia.org/wiki/Multicast_DNS
        // * DNS - http://tools.ietf.org/html/rfc1035
        // For more on DNS record types see:
        // * http://en.wikipedia.org/wiki/List_of_DNS_record_types
        
        // DNS header.
        out.writeU16(0); // Id.
        out.writeU16(0x8400); // QR = response, OPCODE = QUERY, RCODE = no error, AA (authoritative answer) = true.
        out.writeU16(0); // QDCOUNT (question records).
        out.writeU16(5); // ANCOUNT (answer records).
        out.writeU16(0); // NSCOUNT (name server records).
        out.writeU16(0); // ARCOUNT (additional records).

        // Answer record 1.
        out.writeName("_device-info", "_udp", "local");
        out.writeU16(TYPE_PTR);
        out.writeU16(CLASS_INTERNET);
        out.writeU32(4500); // TTL 4500s.
        out.beginRdata();
        out.writeName(deviceName, "_device-info", "_udp", "local");
        out.endRdata();
        
        // Answer record 2.
        out.writeName("_services", "_dns-sd", "_udp", "local");
        // Note: oddly the CC3000 is inconsistent in it's use of compression
        // and does not compress the "_udp.local." portion of this name.
        out.writeU16(TYPE_PTR);
        out.writeU16(CLASS_INTERNET);
        out.writeU32(4500); // TTL 4500s.
        out.beginRdata();
        out.writeName("_device-info", "_udp", "local");
        out.endRdata();

        // Answer record 3.
        out.writeName(deviceName, "_device-info", "_udp", "local");
        out.writeU16(TYPE_TXT);
        out.writeU16(setCacheFlushBit(CLASS_INTERNET));
        out.writeU32(4500); // TTL 4500s.
        out.beginRdata();
        out.writeString("dev=CC3000"); // Note: dev is the device type and does not change with the device name.
        out.writeString("vendor=Texas-Instruments");
        out.endRdata();
        
        // Answer record 4.
        out.writeName(deviceName, "_device-info", "_udp", "local");
        out.writeU16(TYPE_SRV);
        out.writeU16(setCacheFlushBit(CLASS_INTERNET));
        out.writeU32(4500); // TTL 4500s.
        out.beginRdata();
        out.writeU16(0); // Priority 0.
        out.writeU16(0); // Weight 0.
        out.writeU16(1234); // Port 1234.
        out.writeName("target", "local");
        out.endRdata();
        
        // Answer record 5.
        out.writeName("target", "local");
        out.writeU16(TYPE_A);
        out.writeU16(setCacheFlushBit(CLASS_INTERNET));
        out.writeU32(4500); // TTL 4500s.
        out.beginRdata();
        out.writeBytes(getLocalHostAddress()); // Claim that this machine is the CC3000 enabled device.
        out.endRdata();
        
        return out.toByteArray();
    }

    // The cache-flush bit is specific to mDNS.
    // See http://tools.ietf.org/html/rfc6762 section 10.2
    private int setCacheFlushBit(int i)
    {
        return 0x8000 | i;
    }
    
    private byte[] getLocalHostAddress()
    {
        try
        {
            // We don't want the loopback address so we don't use InetAddress.getLocalHost().
            Iterable<NetworkInterface> interfaces =
                Collections.list(NetworkInterface.getNetworkInterfaces());
            
            for (NetworkInterface i : interfaces)
            {
                if (!i.isLoopback() && i.isUp())
                {
                    Iterable<InetAddress> addresses = 
                        Collections.list(i.getInetAddresses());
                    
                    for (InetAddress a : addresses)
                    {
                        if (a instanceof Inet4Address)
                        {
                            return a.getAddress();
                        }
                    }
                }
            }
            
            System.err.println("Error: could not find IP address");
        }
        catch (Exception e)
        {
            e.printStackTrace();
        }
        
        System.exit(1);
        return null;
    }
    
    private static byte[] toBytes(int... i)
    {
        byte[] result = new byte[i.length];
        
        for (int j = 0; j < i.length; j++)
        {
            result[j] = (byte)i[j];
        }
        
        return result;
    }
    
    private static class WireFormat
    {
        private final ByteBuffer buffer = ByteBuffer.allocate(512);
        
        private int rdataPosition = -1;
        
        public void writeU16(int i)
        {
            buffer.putShort((short)i);
        }
        
        public void writeU32(long l)
        {
            buffer.putInt((int)l);
        }
        
        // Unlike the real CC3000 we do not use compression for names.
        // See http://tools.ietf.org/html/rfc1035 section 4.1.4.
        public void writeName(String... elements)
        {
            for (String s : elements)
            {
                writeString(s);
            }
            buffer.put((byte)0);
        }
        
        public void writeString(String s)
        {
            buffer.put((byte)s.length());
            buffer.put(s.getBytes(Charsets.ISO_8859_1));
            // See http://en.wikipedia.org/wiki/Domain_Name_System#Domain_name_syntax
            // for discussion of DNS character set.
        }
        
        public void writeBytes(byte[] b)
        {
            buffer.put(b);
        }
        
        public void beginRdata()
        {
            rdataPosition = buffer.position();
            buffer.position(rdataPosition + 2);
        }
        
        public void endRdata()
        {
            int length = buffer.position() - (rdataPosition + 2);
            buffer.putShort(rdataPosition, (short)length);
        }
        
        public byte[] toByteArray()
        {
            buffer.flip();
            byte[] result = new byte[buffer.remaining()];
            buffer.get(result);
            
            return result;
        }
    }
}
